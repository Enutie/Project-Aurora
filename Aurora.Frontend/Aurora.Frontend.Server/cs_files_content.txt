Filename: CardDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\CardDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace Aurora.Application.DTO
{

    [JsonDerivedType(typeof(CreatureDTO))]
    [JsonDerivedType(typeof(LandDTO))]
    public class CardDTO
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public bool IsTapped { get; set; } = false;
        public virtual string Type { get; set; } = "Card";
    }
}

--------------------------------------------------
Filename: CreatureDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\CreatureDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.DTO
{
    public class CreatureDTO : CardDTO
    {
        public List<string> ManaCost { get; set; }
        public int Power { get; set; }
        public int Toughness { get; set; }
        public bool IsAttacking { get; set; }
        public bool IsBlocked { get; set; }
        public CreatureDTO BlockedBy { get; set; }
        public override string Type { get; set; } = "Creature";
    }
}

--------------------------------------------------
Filename: GameDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\GameDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.Json.Serialization;

namespace Aurora.Application.DTO
{
    public class GameDTO
    {
        public string Id { get; set; }
        public List<PlayerDTO> Players { get; set; }
        public int CurrentPlayerIndex { get; set; }
        public bool IsGameOver { get; set; }
        public PlayerDTO Winner { get; set; }
        public string CurrentPhase { get; set; }
    }
}

--------------------------------------------------
Filename: LandDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\LandDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.DTO
{
    public class LandDTO : CardDTO
    {
        public string LandType { get; set; }
        public override string Type { get; set; } = "Land";
    }
}

--------------------------------------------------
Filename: ManaPoolDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\ManaPoolDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.DTO
{
    public class ManaPoolDTO
    {
        public Dictionary<string, int> Mana { get; set; }
    }
}

--------------------------------------------------
Filename: PlayerDTO.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\DTO\PlayerDTO.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.DTO
{
    public class PlayerDTO
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public List<CardDTO> Hand { get; set; }
        public List<CardDTO> Battlefield { get; set; }
        public List<CardDTO> Graveyard { get; set; }
        public int Life { get; set; }
    }
}

--------------------------------------------------
Filename: IGameQueryService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Interfaces\IGameQueryService.cs
Content:
﻿using Aurora.Application.DTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Interfaces
{
    public interface IGameQueryService
    {
        PlayerDTO GetPlayerInfo(string gameId, string playerId);
        LandDTO GetLandById(string landId);
        CreatureDTO GetCreatureById(string creatureId);
    }
}

--------------------------------------------------
Filename: IGameService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Interfaces\IGameService.cs
Content:
﻿using Aurora.Application.DTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Interfaces
{
    public interface IGameService
    {
        GameDTO CreateGame(string playerName);
        GameDTO StartGame(List<PlayerDTO> playerDTOs);
        GameDTO PlayLand(string gameId, string playerId, LandDTO landDTO);
        GameDTO CastCreature(string gameId, string playerId, CreatureDTO creatureDTO);
        GameDTO Attack(string gameId, string attackingPlayerId, List<string> attackingCreatureIds);
        GameDTO AssignBlockers(string gameId, string defendingPlayerId, Dictionary<string, string> blockerAssignments);
        GameDTO SwitchTurn(string gameId);
        GameDTO GetGameState(string gameId);
        GameDTO AdvanceToNextPhase(string gameId);
        PlayerDTO GetPlayerInfo(string gameId, string playerId);
        LandDTO GetLandById(string landId);
        CreatureDTO GetCreatureById(string creatureId);
    }
}

--------------------------------------------------
Filename: IPlayerActionService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Interfaces\IPlayerActionService.cs
Content:
﻿using Aurora.Application.DTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Interfaces
{
    public interface IPlayerActionService
    {
        GameDTO PlayLand(string gameId, string playerId, LandDTO landDTO);
        GameDTO CastCreature(string gameId, string playerId, CreatureDTO creatureDTO);
        GameDTO Attack(string gameId, string attackingPlayerId, List<string> attackingCreatureIds);
        GameDTO AssignBlockers(string gameId, string defendingPlayerId, Dictionary<string, string> blockerAssignments);
    }
}

--------------------------------------------------
Filename: GameManager.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Services\GameManager.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Domain.Entities;
using Aurora.Infrastructure.Interfaces;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Services
{
    public class GameManager : IGameManager
    {
        private readonly ILogger<GameManager> _logger;
        private readonly IGameStorage _games;
        private readonly ICardConverter _cardConverter;

        public GameManager(ILogger<GameManager> logger, IGameStorage gameStorage, ICardConverter cardConverter)
        {
            _logger = logger;
            _games = gameStorage;
            _cardConverter = cardConverter;
        }

        public GameDTO AdvanceToNextPhase(string gameId)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }
                game.AdvanceToNextPhase();
                return CreateGameDTOFromGame(game);
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not found");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while advancing to the next phase.");
                throw new InvalidOperationException("An error occurred while advancing to the next phase.", ex);
            }
        }

        public GameDTO CreateGame(string playerName)
        {
            var game = new Game(new List<Player>() {
        new Player(playerName),
        new Player("AI")
    }, _cardConverter);
            _games.AddGame(game);

            return CreateGameDTOFromGame(game);
        }

        public GameDTO GetGameState(string gameId)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }
                return CreateGameDTOFromGame(game);
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not found");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while retrieving the game state.");
                throw new InvalidOperationException("An error occurred while retrieving the game state.", ex);
            }
        }

        public GameDTO StartGame(List<PlayerDTO> playerDTOs)
        {
            try
            {
                var players = playerDTOs.Select(p => new Player
                {
                    Id = p.Id,
                    Name = p.Name,
                    Life = p.Life
                }).ToList();

                var game = new Game(players, _cardConverter);
                _games.AddGame(game);

                return CreateGameDTOFromGame(game);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to start the game.");
                throw new InvalidOperationException("Failed to start the game.", ex);
            }
        }

        public GameDTO SwitchTurn(string gameId)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                game.SwitchTurn();
                return GetGameState(gameId);
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not found");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while switching turns.");
                throw new InvalidOperationException("An error occurred while switching turns.", ex);
            }
        }

        private GameDTO CreateGameDTOFromGame(Game game)
        {
            var gameState = game.GetGameState();
            return new GameDTO
            {
                Id = gameState.Id,
                Players = gameState.Players.Select(p => new PlayerDTO
                {
                    Id = p.Id,
                    Name = p.Name,
                    Hand = p.Hand.Cast<CardDTO>().ToList(),
                    Battlefield = p.Battlefield.Cast<CardDTO>().ToList(),
                    Life = p.Life
                }).ToList(),
                CurrentPlayerIndex = gameState.CurrentPlayerIndex,
                IsGameOver = gameState.IsGameOver,
                Winner = gameState.Winner,
                CurrentPhase = gameState.CurrentPhase.ToString(),
            };
        }
    }
}

--------------------------------------------------
Filename: GameQueryService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Services\GameQueryService.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Application.Interfaces;
using Aurora.Domain.Entities;
using Aurora.Infrastructure.Interfaces;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Services
{
    public class GameQueryService : IGameQueryService
    {
        private readonly ILogger<GameQueryService> _logger;
        private readonly IGameStorage _games;
        private readonly ICardConverter _cardConverter;

        public GameQueryService(ILogger<GameQueryService> _logger, IGameStorage _games, ICardConverter cardConverter)
        {
            this._logger = _logger;
            this._games = _games;
            _cardConverter = cardConverter;
        }

        public CreatureDTO GetCreatureById(string creatureId)
        {
            var games = _games.GetAllGames();
            var game = games.FirstOrDefault(g => g.GetGameState().Players.Any(p => p.Hand.Any(c => c.Id == creatureId && c is Creature)));

            if (game == null)
            {
                return null;
            }

            var creature = game.GetGameState().Players.SelectMany(p => p.Hand).OfType<Creature>().FirstOrDefault(c => c.Id == creatureId);

            if (creature == null)
            {
                return null;
            }

            return new CreatureDTO
            {
                Id = creature.Id,
                Name = creature.Name,
                ManaCost = creature.ManaCost.Select(m => m.ToString()).ToList(),
                Power = creature.Power,
                Toughness = creature.Toughness
            };
        }

        public LandDTO GetLandById(string landId)
        {
            var games = _games.GetAllGames();
            var game = games.FirstOrDefault(g => g.GetGameState().Players.Any(p => p.Hand.Any(c => c.Id == landId && c is Land)));

            if (game == null)
            {
                return null;
            }

            var land = game.GetGameState().Players.SelectMany(p => p.Hand).OfType<Land>().FirstOrDefault(l => l.Id == landId);

            if (land == null)
            {
                return null;
            }

            return new LandDTO
            {
                Id = land.Id,
                LandType = land.Type.ToString()
            };
        }

        public PlayerDTO GetPlayerInfo(string gameId, string playerId)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                var player = game.GetGameState().Players.FirstOrDefault(p => p.Id == playerId);
                if (player == null)
                {
                    throw new PlayerNotFoundException($"Player with ID '{playerId}' not found in the game.");
                }

                return new PlayerDTO
                {
                    Id = player.Id,
                    Name = player.Name,
                    Hand = player.Hand,
                    Battlefield = player.Battlefield,
                    Life = player.Life
                };
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not found");
                throw;
            }
            catch (PlayerNotFoundException ex)
            {
                _logger.LogError(ex, "Player not found");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while retrieving player information.");
                throw new InvalidOperationException("An error occurred while retrieving player information.", ex);
            }
        }
    }


}

--------------------------------------------------
Filename: GameService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Services\GameService.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Application.Interfaces;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace Aurora.Application.Services
{
    public class GameService : IGameService
    {
        private readonly ILogger<GameService> _logger;
        private readonly IGameManager _gameManager;
        private readonly IPlayerActionService _playerActionService;
        private readonly IGameQueryService _gameQueryService;
        private readonly ICardConverter _cardConverter;
        public GameService(ILogger<GameService> logger, IGameManager gameManager, IPlayerActionService playerActionService, IGameQueryService gameQueryService, ICardConverter cardConverter)
        {
            _logger = logger;
            _gameManager = gameManager;
            _playerActionService = playerActionService;
            _gameQueryService = gameQueryService;
            _cardConverter = cardConverter;
        }

        public GameDTO CreateGame(string playerName)
        {
            return _gameManager.CreateGame(playerName);
        }

        public GameDTO StartGame(List<PlayerDTO> playerDTOs)
        {
            return _gameManager.StartGame(playerDTOs);
        }

        public GameDTO PlayLand(string gameId, string playerId, LandDTO landDTO)
        {
            return _playerActionService.PlayLand(gameId, playerId, landDTO);
        }

        public GameDTO CastCreature(string gameId, string playerId, CreatureDTO creatureDTO)
        {
            return _playerActionService.CastCreature(gameId, playerId, creatureDTO);
        }

        public GameDTO Attack(string gameId, string attackingPlayerId, List<string> attackingCreatureIds)
        {
            return _playerActionService.Attack(gameId, attackingPlayerId, attackingCreatureIds);
        }

        public GameDTO AssignBlockers(string gameId, string defendingPlayerId, Dictionary<string, string> blockerAssignments)
        {
            return _playerActionService.AssignBlockers(gameId, defendingPlayerId, blockerAssignments);
        }

        public GameDTO SwitchTurn(string gameId)
        {
            return _gameManager.SwitchTurn(gameId);
        }

        public GameDTO GetGameState(string gameId)
        {
            return _gameManager.GetGameState(gameId);
        }

        public PlayerDTO GetPlayerInfo(string gameId, string playerId)
        {
            return _gameQueryService.GetPlayerInfo(gameId, playerId);
        }

        public LandDTO GetLandById(string landId)
        {
            return _gameQueryService.GetLandById(landId);
        }

        public CreatureDTO GetCreatureById(string creatureId)
        {
            return _gameQueryService.GetCreatureById(creatureId);
        }

        public GameDTO AdvanceToNextPhase(string gameId)
        {
            return _gameManager.AdvanceToNextPhase(gameId);
        }
    }
}

--------------------------------------------------
Filename: IGameManager.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Services\IGameManager.cs
Content:
﻿using Aurora.Application.DTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Application.Services
{
    public interface IGameManager
    {
        GameDTO CreateGame(string playerName);
        GameDTO StartGame(List<PlayerDTO> playerDTOs);
        GameDTO GetGameState(string gameId);
        GameDTO AdvanceToNextPhase(string gameId);

        GameDTO SwitchTurn(string gameId);
    }
}

--------------------------------------------------
Filename: PlayerActionService.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Application\Services\PlayerActionService.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Application.Interfaces;
using Aurora.Infrastructure.Interfaces;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Entities;
using Aurora.Domain.Enums;

namespace Aurora.Application.Services
{

    public class PlayerActionService : IPlayerActionService
    {
        private readonly ILogger<PlayerActionService> _logger;
        private readonly IGameStorage _games;
        private readonly IGameManager _gameManager;
        private readonly ICardConverter _cardConverter;

        public PlayerActionService(ILogger<PlayerActionService> logger, IGameStorage games, IGameManager gameManager, ICardConverter cardConverter)
        {
            _logger = logger;
            _games = games;
            _gameManager = gameManager;
            _cardConverter = cardConverter;
        }

        public GameDTO AssignBlockers(string gameId, string defendingPlayerId, Dictionary<string, string> blockerAssignments)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                game.AssignBlockers(defendingPlayerId, blockerAssignments);

                return game.GetGameState();
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not found");
                throw;
            }
            catch (PlayerNotFoundException ex)
            {
                _logger.LogError(ex, "Player not found");
                throw;
            }
        }

        public GameDTO Attack(string gameId, string attackingPlayerId, List<string> attackingCreatureIds)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                game.DeclareAttackers(attackingPlayerId, attackingCreatureIds);

                return game.GetGameState();
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not Found");
                throw;
            }
            catch (PlayerNotFoundException ex)
            {
                _logger.LogError(ex, "Player not Found");
                throw;
            }
            catch (InvalidOperationException ex)
            {
                _logger.LogError(ex, "Invalid move. " + ex.Message);
                throw new InvalidMoveException("Invalid move. " + ex.Message, ex);
            }
            catch (InvalidPhaseException ex)
            {
                _logger.LogError(ex, "Can only attack in the combat phase");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while attacking.");
                throw new InvalidOperationException("An error occurred while attacking.", ex);
            }
        }

        public GameDTO CastCreature(string gameId, string playerId, CreatureDTO creatureDTO)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                game.CastCreature(playerId, creatureDTO);

                return game.GetGameState();
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, "Game not Found");
                throw;
            }
            catch (PlayerNotFoundException ex)
            {
                _logger.LogError(ex, "Player not Found");
                throw;
            }
            catch (InvalidOperationException ex)
            {
                _logger.LogError(ex, "Invalid Move" + ex.Message);
                throw new InvalidMoveException("Invalid move. " + ex.Message, ex);
            }
            catch (InvalidPhaseException ex)
            {
                _logger.LogError(ex, "Can only play creatures in first or second mainphase");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while casting a creature.");
                throw new InvalidOperationException("An error occurred while casting a creature.", ex);
            }
        }

        public GameDTO PlayLand(string gameId, string playerId, LandDTO landDTO)
        {
            try
            {
                if (!_games.TryGetGame(gameId, out var game))
                {
                    throw new GameNotFoundException($"Game with ID '{gameId}' not found.");
                }

                game.PlayLand(playerId, landDTO);

                return game.GetGameState();
            }
            catch (GameNotFoundException ex)
            {
                _logger.LogError(ex, $"Game with ID '{gameId}' not found.");
                throw;
            }
            catch (PlayerNotFoundException ex)
            {
                _logger.LogError(ex, $"Player with ID '{playerId}' not found in the game.");
                throw;
            }
            catch (InvalidOperationException ex)
            {
                _logger.LogError(ex, "Invalid move. " + ex.Message);
                throw new InvalidMoveException("Invalid move. " + ex.Message, ex);
            }
            catch (InvalidPhaseException ex)
            {
                _logger.LogError(ex, "Invalid move. " + ex.Message);
                throw new InvalidMoveException("Invalid move. " + ex.Message, ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An error occurred while playing a land.");
                throw new InvalidOperationException("An error occurred while playing a land.", ex);
            }
        }
    }
}

--------------------------------------------------
Filename: Card.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Card.cs
Content:
﻿namespace Aurora.Domain.Entities
{
    public class Card
    {
        public string Name { get; }
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public bool IsTapped { get; set; } = false;

        public Card(string name)
        {
            Name = name;
        }
    }
}

--------------------------------------------------
Filename: Creature.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Creature.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Enums;

namespace Aurora.Domain.Entities
{
    public class Creature : Card
    {
        public Creature(string name) : base(name)
        {
        }

        public Creature(string name, IEnumerable<Mana> manaCost,
            int power, int toughness) : base(name)
        {
            ManaCost = manaCost;
            Power = power;
            Toughness = toughness;
        }

        public IEnumerable<Mana> ManaCost { get; set; }
        public int Power { get; set; }
        public int Toughness { get; set; }
        public bool IsAttacking { get; set; } = false;
        public bool IsBlocked { get; set; } = false;
        public Creature BlockedBy { get; set; }

        public void DealDamage(Creature target)
        {
            target.Toughness -= Power;
        }

    }
}

--------------------------------------------------
Filename: Deck.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Deck.cs
Content:
﻿using Aurora.Domain.Entities;
using Aurora.Domain.Enums;

public class Deck
{
    public List<Card> Cards { get; private set; }
    private readonly Random _random = new Random();

    public Deck(IEnumerable<(LandType Type, int Count)> landCounts)
    {
        Cards = new List<Card>();
        foreach (var landCount in landCounts)
        {
            for (int i = 0; i < landCount.Count; i++)
            {
                Cards.Add(new Land(landCount.Type));
            }
        }
    }

    public Deck(IEnumerable<Card> cards)
    {
        Cards = cards.ToList();
    }

    public void Shuffle()
    {
        Cards = Cards.OrderBy(x => _random.Next()).ToList();
    }
}
--------------------------------------------------
Filename: Game.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Game.cs
Content:
﻿// Domain/Entities/Game.
using Aurora.Application.DTO;
using Aurora.Domain.Enums;
using Aurora.Domain.Services;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;

namespace Aurora.Domain.Entities
{
    public class Game
    {
        private readonly GameState _gameState;
        private readonly TurnManager _turnManager;
        private readonly CombatManager _combatManager;
        private readonly ICardConverter _cardConverter;

        public Game(List<Player> players, ICardConverter cardConverter)
        {
            _gameState = new GameState(players);
            _cardConverter = cardConverter;
            _turnManager = new TurnManager(_gameState, _cardConverter);
            _combatManager = new CombatManager(_gameState);
            StartGame();
        }

        public void StartGame()
        {
            _turnManager.StartGame();
        }

        // In Game.cs
        public void AdvanceToNextPhase()
        {
            _turnManager.AdvanceToNextPhase();
            CheckWinConditions();
            Console.WriteLine($"Advanced to phase: {_gameState.CurrentPhase}");
        }

        public void PlayLand(string playerId, LandDTO landDTO)
        {
            _turnManager.PlayLand(playerId, landDTO);
        }

        public void CastCreature(string playerId, CreatureDTO creatureDTO)
        {
            if (_gameState.CurrentPhase != Phase.MainPhase1 && _gameState.CurrentPhase != Phase.MainPhase2)
            {
                throw new InvalidPhaseException("Can only play a creature in first or second main phase");
            }

            var player = _gameState.GetPlayerById(playerId);
            var creature = _cardConverter.ConvertToCreature(creatureDTO);

            if (!player.Hand.Any(c => c.Id == creature.Id))
            {
                throw new InvalidMoveException("The creature is not in the player's hand.");
            }

            if (player.ManaPool.CanAfford(creature.ManaCost))
            {
                player.ManaPool.Spend(creature.ManaCost);
                player.Hand.RemoveAll(c => c.Id == creature.Id);
                player.Battlefield.Add(creature);
            }
            else
            {
                throw new InvalidMoveException("Player does not have enough mana to cast the creature.");
            }
        }

        public void DeclareAttackers(string attackingPlayerId, List<string> attackingCreatureIds)
        {
            var attackingPlayer = _gameState.GetPlayerById(attackingPlayerId);
            var attackingCreatures = attackingPlayer.Battlefield.OfType<Creature>()
                .Where(c => attackingCreatureIds.Contains(c.Id)).ToList();

            _combatManager.DeclareAttackers(attackingPlayer, attackingCreatures);
        }

        public void AssignBlockers(string defendingPlayerId, Dictionary<string, string> blockerAssignments)
        {
            var defendingPlayer = _gameState.GetPlayerById(defendingPlayerId);
            var blockingCreatures = new Dictionary<Creature, Creature>();

            foreach (var assignment in blockerAssignments)
            {
                var attackingCreature = _gameState.Players.SelectMany(p => p.Battlefield).OfType<Creature>().FirstOrDefault(c => c.Id == assignment.Key);
                var blockingCreature = defendingPlayer.Battlefield.OfType<Creature>().FirstOrDefault(c => c.Id == assignment.Value);

                if (attackingCreature != null && blockingCreature != null)
                {
                    blockingCreatures[attackingCreature] = blockingCreature;
                }
            }

            _combatManager.AssignBlockers(defendingPlayer, blockingCreatures);
        }
        public GameDTO GetGameState()
        {
            return new GameDTO
            {
                Id = _gameState.Id,
                Players = _gameState.Players.Select(_cardConverter.ConvertToPlayerDTO).ToList(),
                CurrentPlayerIndex = _gameState.CurrentPlayerIndex,
                IsGameOver = _gameState.IsGameOver,
                Winner = _gameState.Winner,
                CurrentPhase = _gameState.CurrentPhase.ToString(),
            };
        }

        public GameDTO SwitchTurn()
        {
            _turnManager.SwitchTurn();
            CheckWinConditions();
            return GetGameState();
        }

        private void CheckWinConditions()
        {
            foreach (var player in _gameState.Players)
            {
                if (player.Life <= 0 || player.Deck.Cards.Count == 0)
                {
                    _gameState.IsGameOver = true;
                    _gameState.Winner = _cardConverter.ConvertToPlayerDTO(_gameState.Players.FirstOrDefault(p => p != player));
                    break;
                }
            }
        }
    }
}
--------------------------------------------------
Filename: GameState.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\GameState.cs
Content:
﻿using System;
using System.Collections.Generic;
using Aurora.Application.DTO;
using Aurora.Domain.Enums;

namespace Aurora.Domain.Entities
{
    public class GameState
    {
        public List<Player> Players { get; }
        public int CurrentPlayerIndex { get; set; } = 0;
        public string Id { get; } = Guid.NewGuid().ToString();
        public bool IsGameOver { get; set; }
        public PlayerDTO Winner { get; set; }
        public Phase CurrentPhase { get; set; }
        public Dictionary<string, int> LandsPlayedThisTurn { get; } = new Dictionary<string, int>();
        public bool HasAttackedThisTurn { get; set; }

        public GameState(List<Player> players)
        {
            Players = players;
            foreach (var player in Players)
            {
                LandsPlayedThisTurn[player.Id] = 0;
            }
        }

        public Player GetCurrentPlayer() => Players[CurrentPlayerIndex];
        public string GetCurrentPlayerId() => GetCurrentPlayer().Id;
        public Player GetPlayerById(string id) => Players.Find(p => p.Id == id);
    }
}
--------------------------------------------------
Filename: Land.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Land.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Enums;

namespace Aurora.Domain.Entities
{

    public class Land : Card
    {
        public LandType Type { get; }
        public Mana ProducedMana => Type switch
        {
            LandType.Plains => Mana.White,
            LandType.Island => Mana.Blue,
            LandType.Swamp => Mana.Black,
            LandType.Mountain => Mana.Red,
            LandType.Forest => Mana.Green,
            _ => throw new ArgumentOutOfRangeException(nameof(Type))
        };

        public Land(LandType type) : base(type.ToString())
        {
            Type = type;
        }
    }
}

--------------------------------------------------
Filename: ManaPool.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\ManaPool.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Enums;

namespace Aurora.Domain.Entities
{
    public class ManaPool
    {
        public Dictionary<Mana, int> _mana = new Dictionary<Mana, int>();
        public List<Land> LandsUsed { get; } = new List<Land>();


        public void Add(Mana mana, Land land)
        {
            if (_mana.ContainsKey(mana))
            {
                _mana[mana]++;
            }
            else
            {
                _mana[mana] = 1;
            }
            LandsUsed.Add(land);
        }

        public bool CanAfford(IEnumerable<Mana> cost)
        {
            var remainingCost = cost.GroupBy(m => m).ToDictionary(g => g.Key, g => g.Count());
            int colorlessCost = remainingCost.ContainsKey(Mana.Colorless) ? remainingCost[Mana.Colorless] : 0;

            if (remainingCost.ContainsKey(Mana.Colorless))
            {
                remainingCost.Remove(Mana.Colorless);
            }

            var availableMana = LandsUsed.Where(l => !l.IsTapped).GroupBy(l => l.ProducedMana).ToDictionary(g => g.Key, g => g.Count());

            foreach (var (mana, count) in availableMana)
            {
                if (remainingCost.ContainsKey(mana))
                {
                    int usedMana = Math.Min(count, remainingCost[mana]);
                    remainingCost[mana] -= usedMana;
                    colorlessCost -= count - usedMana;

                    if (remainingCost[mana] <= 0)
                    {
                        remainingCost.Remove(mana);
                    }
                }
                else
                {
                    colorlessCost -= count;
                }
            }

            return !remainingCost.Any() && colorlessCost <= 0;
        }


        public void Spend(IEnumerable<Mana> cost)
        {
            if (!CanAfford(cost))
            {
                throw new InvalidOperationException("Insufficient mana to spend.");
            }

            var remainingCost = cost.GroupBy(m => m).ToDictionary(g => g.Key, g => g.Count());

            foreach (var mana in cost)
            {
                if (mana == Mana.Colorless)
                    continue;

                var landToTap = LandsUsed.FirstOrDefault(l => l.ProducedMana == mana && !l.IsTapped);
                if (landToTap != null)
                {
                    landToTap.IsTapped = true;
                    remainingCost[mana]--;
                    if (remainingCost[mana] == 0)
                    {
                        remainingCost.Remove(mana);
                    }
                }
            }

            // Spend colorless mana
            int colorlessCost = remainingCost.ContainsKey(Mana.Colorless) ? remainingCost[Mana.Colorless] : 0;
            while (colorlessCost > 0)
            {
                var landToTap = LandsUsed.FirstOrDefault(l => !l.IsTapped);
                if (landToTap != null)
                {
                    landToTap.IsTapped = true;
                    colorlessCost--;
                }
                else
                {
                    throw new InvalidOperationException("Insufficient mana to spend.");
                }
            }
        }
        public IEnumerable<Mana> AvailableMana()
        {
            return _mana.Keys;
        }

        public void Clear()
        {
            _mana.Clear();
            LandsUsed.Clear();
        }
    }
}

--------------------------------------------------
Filename: Player.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Entities\Player.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Factories;

namespace Aurora.Domain.Entities
{
    public class Player
    {
        public List<Card> Hand { get; } = new List<Card>();
        public List<Card> Battlefield { get; } = new List<Card>();
        public List<Card> Graveyard { get; set; } = new List<Card>();
        public Deck Deck { get; set; }
        public string Name { get; set; }
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public ManaPool ManaPool { get; } = new ManaPool();
        public int Life { get; set; } = 20;
        public void TakeDamage(int damage)
        {
            Life -= damage;
        }

        public Player(string name)
        {
            Name = name;
            Deck = DeckFactory.MonoGreenVanilla();
            Deck.Shuffle();
        }

        public Player()
        {

        }

        public void PlayLand(Land land)
        {
            Land landToRemove = (Land)Hand.FirstOrDefault(l => l.Id == land.Id);
            if (landToRemove != null)
            {
                Hand.Remove(landToRemove);
                Battlefield.Add(landToRemove);
                ManaPool.Add(landToRemove.ProducedMana, landToRemove);
            }
        }

        public void DrawCard()
        {
            if (Deck.Cards.Count == 0)
            {
                throw new InvalidOperationException("Player has no more cards to draw.");
            }

            Card drawnCard = Deck.Cards.First();
            Deck.Cards.RemoveAt(0);
            Hand.Add(drawnCard);
        }

        public Dictionary<string, string> AssignBlockers(List<string> attackingCreatureIds)
        {
            var blockingAssignments = new Dictionary<string, string>();

            foreach (var attackerId in attackingCreatureIds)
            {
                var blocker = Battlefield.OfType<Creature>().FirstOrDefault(c => !c.IsAttacking && !blockingAssignments.ContainsValue(c.Id));
                if (blocker != null)
                {
                    blockingAssignments[attackerId] = blocker.Id;
                }
            }

            return blockingAssignments;
        }
    }
}

--------------------------------------------------
Filename: LandType.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Enums\LandType.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Domain.Enums
{
    public enum LandType
    {
        Plains,
        Island,
        Swamp,
        Mountain,
        Forest
    }
}

--------------------------------------------------
Filename: Mana.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Enums\Mana.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Domain.Enums
{
    public enum Mana
    {
        White, Blue, Black, Red, Green, Colorless
    }
}

--------------------------------------------------
Filename: Phase.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Enums\Phase.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Domain.Enums
{
    public enum Phase
    {
        Beginning,
        MainPhase1,
        Combat,
        MainPhase2,
        Ending
    }
}

--------------------------------------------------
Filename: DeckFactory.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Factories\DeckFactory.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Entities;
using Aurora.Domain.Enums;

namespace Aurora.Domain.Factories
{
    public static class DeckFactory
    {
        public static Deck CreateDeck(LandType landType)
        {
            List<Card> cards = new List<Card>();
            for (int i = 0; i < 60; i++)
            {
                cards.Add(new Land(landType));
            }

            return new Deck(cards);
        }

        public static Deck MonoGreenVanilla()
        {
            List<Card> cards = new List<Card>();
            for (int i = 0; i < 24; i++)
            {
                cards.Add(new Land(LandType.Forest));
            }
            for (int i = 0; i < 4; i++)
            {
                cards.Add(new Creature("Woodland Druid", new[] { Mana.Green }, 1, 2));
                cards.Add(new Creature("Bear Cub", new[] { Mana.Green, Mana.Colorless }, 2, 2));
                cards.Add(new Creature("Barbary Apes", new[] { Mana.Green, Mana.Colorless }, 2, 2));
                cards.Add(new Creature("Cylian Elf", new[] { Mana.Green, Mana.Colorless }, 2, 2));
                cards.Add(new Creature("Alpine Grizzly", new[] { Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 4, 2));
                cards.Add(new Creature("Centaur Courser", new[] { Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 3, 3));
                cards.Add(new Creature("Axebane Beast", new[] { Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 3, 4));
            }
            for (int i = 0; i < 2; i++)
            {
                cards.Add(new Creature("Delighted Killbot", new[] { Mana.Colorless, Mana.Colorless }, 2, 1));
                cards.Add(new Creature("Broodhunter Wurm", new[] { Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 4, 3));
                cards.Add(new Creature("Feral Krushok", new[] { Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 5, 4));
                cards.Add(new Creature("Alpha Tyrranax", new[] { Mana.Green, Mana.Green, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless, Mana.Colorless }, 6, 5));
            }
            return new Deck(cards);
        }
    }
}

--------------------------------------------------
Filename: CombatManager.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Services\CombatManager.cs
Content:
﻿using Aurora.Domain.Entities;
using Aurora.Domain.Enums;
using Aurora.Shared.Exceptions;

namespace Aurora.Domain.Services
{
    public class CombatManager
    {
        private readonly GameState _gameState;
        private Player _attackingPlayer;
        private List<Creature> _attackingCreatures;
        private Dictionary<Creature, Creature> _blockingCreatures;

        public CombatManager(GameState gameState)
        {
            _gameState = gameState;
        }

        public void DeclareAttackers(Player attackingPlayer, List<Creature> attackingCreatures)
        {
            if (_gameState.CurrentPhase != Phase.Combat)
            {
                throw new InvalidPhaseException("Can only declare attackers in the combat phase.");
            }

            foreach (var creature in attackingCreatures)
            {
                if (creature.IsTapped)
                {
                    throw new InvalidOperationException("Cannot declare a tapped creature as an attacker.");
                }
                creature.IsAttacking = true;
                creature.IsTapped = true;
            }

            _attackingPlayer = attackingPlayer;
            _attackingCreatures = attackingCreatures;
        }

        public void AssignBlockers(Player defendingPlayer, Dictionary<Creature, Creature> blockingCreatures)
        {
            if (_gameState.CurrentPhase != Phase.Combat)
            {
                throw new InvalidPhaseException("Can only assign blockers in the combat phase.");
            }

            _blockingCreatures = blockingCreatures;
            ResolveCombat(defendingPlayer);
        }

        private void ResolveCombat(Player defendingPlayer)
        {
            foreach (var attackingCreature in _attackingCreatures)
            {
                if (_blockingCreatures.TryGetValue(attackingCreature, out var blockingCreature))
                {
                    attackingCreature.DealDamage(blockingCreature);
                    blockingCreature.DealDamage(attackingCreature);
                    RemoveDeadCreature(attackingCreature, _attackingPlayer);
                    RemoveDeadCreature(blockingCreature, defendingPlayer);
                }
                else
                {
                    defendingPlayer.TakeDamage(attackingCreature.Power);
                }
                attackingCreature.IsAttacking = false;
            }

            _attackingCreatures.Clear();
            _blockingCreatures.Clear();
            _gameState.HasAttackedThisTurn = true;
        }

        private void RemoveDeadCreature(Creature creature, Player owner)
        {
            if (creature.Toughness <= 0)
            {
                owner.Battlefield.Remove(creature);
                owner.Graveyard.Add(creature);
            }
        }
    }
}
--------------------------------------------------
Filename: TurnManager.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Domain\Services\TurnManager.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Domain.Entities;
using Aurora.Domain.Enums;
using Aurora.Shared.Exceptions;
using Aurora.Shared.Utils;

namespace Aurora.Domain.Services
{
    public class TurnManager
    {
        private readonly GameState _gameState;
        private readonly ICardConverter _cardConverter;

        public TurnManager(GameState gameState, ICardConverter cardConverter)
        {
            _gameState = gameState;
            _cardConverter = cardConverter;
        }

        public void StartGame()
        {
            foreach (Player player in _gameState.Players)
            {
                player.Deck.Shuffle();
                DrawStartingHand(player);
            }
            StartBeginningPhase();
        }

        public void AdvanceToNextPhase()
        {
            switch (_gameState.CurrentPhase)
            {
                case Phase.Beginning:
                    StartMainPhase1();
                    break;
                case Phase.MainPhase1:
                    StartCombatPhase();
                    break;
                case Phase.Combat:
                    StartMainPhase2();
                    break;
                case Phase.MainPhase2:
                    StartEndPhase();
                    break;
                case Phase.Ending:
                    SwitchTurn();
                    break;
                default:
                    throw new InvalidOperationException("Unknown phase.");
            }
        }

        // In TurnManager.cs
        public void PlayLand(string playerId, LandDTO landDTO)
        {
            Console.WriteLine($"Current Phase: {_gameState.CurrentPhase}");
            Console.WriteLine($"Current Player ID: {_gameState.GetCurrentPlayerId()}");
            Console.WriteLine($"Attempting to play land for player: {playerId}");
            Console.WriteLine($"Lands played this turn: {_gameState.LandsPlayedThisTurn[playerId]}");

            if (_gameState.CurrentPhase != Phase.MainPhase1 && _gameState.CurrentPhase != Phase.MainPhase2)
            {
                throw new InvalidPhaseException("Can only play a land in first or second main phase");
            }

            var player = _gameState.GetPlayerById(playerId);
            if (_gameState.GetCurrentPlayerId() != playerId || !CanPlayLand(playerId))
            {
                throw new InvalidMoveException("Player cannot play a land at this time.");
            }

            var land = _cardConverter.ConvertToLand(landDTO);
            Console.WriteLine($"Land in player's hand: {player.Hand.Any(c => c.Id == land.Id)}");
            player.PlayLand(land);
            _gameState.LandsPlayedThisTurn[playerId]++;
            Console.WriteLine("Land played successfully");
        }

        private void StartBeginningPhase()
        {
            _gameState.CurrentPhase = Phase.Beginning;
            _gameState.LandsPlayedThisTurn[_gameState.GetCurrentPlayerId()] = 0;
            _gameState.HasAttackedThisTurn = false;
            UntapPermanents(_gameState.GetCurrentPlayer());
            DrawCard(_gameState.GetCurrentPlayer());
        }

        private void StartMainPhase1() => _gameState.CurrentPhase = Phase.MainPhase1;
        private void StartCombatPhase() => _gameState.CurrentPhase = Phase.Combat;
        private void StartMainPhase2() => _gameState.CurrentPhase = Phase.MainPhase2;
        private void StartEndPhase() => _gameState.CurrentPhase = Phase.Ending;

        public void SwitchTurn()
        {
            _gameState.CurrentPlayerIndex = (_gameState.CurrentPlayerIndex + 1) % _gameState.Players.Count;
            StartBeginningPhase();
        }

        private void DrawStartingHand(Player player)
        {
            for (int i = 0; i < 7; i++)
            {
                player.DrawCard();
            }
        }

        private static void UntapPermanents(Player currentPlayer)
        {
            foreach (var card in currentPlayer.Battlefield)
            {
                card.IsTapped = false;
            }
        }

        private void DrawCard(Player player)
        {
            try
            {
                player.DrawCard();
            }
            catch (InvalidOperationException)
            {
                SetWinner(_gameState.Players.Find(p => p != player));
            }
        }

        private void SetWinner(Player player)
        {
            _gameState.IsGameOver = true;
            _gameState.Winner = _cardConverter.ConvertToPlayerDTO(player);
        }

        private bool CanPlayLand(string playerId)
        {
            return _gameState.LandsPlayedThisTurn[playerId] == 0;
        }
    }
}
--------------------------------------------------
Filename: IGameStorage.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Infrastructure\Interfaces\IGameStorage.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Entities;

namespace Aurora.Infrastructure.Interfaces
{
    public interface IGameStorage
    {
        void AddGame(Game game);
        Game GetGame(string Id);
        bool TryGetGame(string Id, out Game game);
        void RemoveGame(string Id);
        IEnumerable<Game> GetAllGames();
    }
}

--------------------------------------------------
Filename: InMemoryGameStorage.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Infrastructure\Persistence\InMemoryGameStorage.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Aurora.Domain.Entities;
using Aurora.Infrastructure.Interfaces;

namespace Aurora.Infrastructure.Persistence
{
    public class InMemoryGameStorage : IGameStorage
    {
        private readonly Dictionary<string, Game> _games = new Dictionary<string, Game>();
        public void AddGame(Game game)
        {
            _games[game.GetGameState().Id] = game;
        }

        public IEnumerable<Game> GetAllGames()
        {
            return _games.Values;
        }

        public Game GetGame(string Id)
        {
            return _games[Id];
        }

        public void RemoveGame(string Id)
        {
            _games.Remove(Id);
        }

        public bool TryGetGame(string Id, out Game game)
        {
            return _games.TryGetValue(Id, out game);
        }
    }
}

--------------------------------------------------
Filename: .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
Content:
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

--------------------------------------------------
Filename: Aurora.AssemblyInfo.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\obj\Debug\net8.0\Aurora.AssemblyInfo.cs
Content:
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Aurora")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+114632c02b050467ab684d6d58b466f08948d6ff")]
[assembly: System.Reflection.AssemblyProductAttribute("Aurora")]
[assembly: System.Reflection.AssemblyTitleAttribute("Aurora")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--------------------------------------------------
Filename: Aurora.GlobalUsings.g.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\obj\Debug\net8.0\Aurora.GlobalUsings.g.cs
Content:
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--------------------------------------------------
Filename: AlreadyPlayedALandExpection.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Exceptions\AlreadyPlayedALandExpection.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Exceptions
{
    public class AlreadyPlayedALandExpection : Exception
    {
        public AlreadyPlayedALandExpection(string message) : base(message)
        {

        }

        public AlreadyPlayedALandExpection(string message, Exception innerException) : base(message, innerException)
        {

        }
    }
}

--------------------------------------------------
Filename: GameNotFoundException.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Exceptions\GameNotFoundException.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Exceptions
{
    public class GameNotFoundException : Exception
    {
        public GameNotFoundException(string message) : base(message) { }
    }
}

--------------------------------------------------
Filename: InvalidMoveException.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Exceptions\InvalidMoveException.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Exceptions
{
    public class InvalidMoveException : Exception
    {
        public InvalidMoveException(string message) : base(message) { }
        public InvalidMoveException(string message, Exception innerException) : base(message, innerException) { }
    }
}

--------------------------------------------------
Filename: InvalidPhaseException.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Exceptions\InvalidPhaseException.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Exceptions
{
    public class InvalidPhaseException : Exception
    {
        public InvalidPhaseException(string message) : base(message)
        {

        }

        public InvalidPhaseException(string message, Exception innerException) : base(message, innerException)
        {

        }
    }
}

--------------------------------------------------
Filename: PlayerNotFoundException.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Exceptions\PlayerNotFoundException.cs
Content:
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Exceptions
{
    public class PlayerNotFoundException : Exception
    {
        public PlayerNotFoundException(string message) : base(message) { }
    }
}

--------------------------------------------------
Filename: CardConverter.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Utils\CardConverter.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Domain.Entities;
using Aurora.Domain.Enums;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Utils
{
    public class CardConverter : ICardConverter
    {
        public CardDTO ConvertToCardDTO(Card card)
        {
            switch (card)
            {
                case Creature creature:
                    return new CreatureDTO
                    {
                        Id = creature.Id,
                        Name = creature.Name,
                        Power = creature.Power,
                        Toughness = creature.Toughness,
                        ManaCost = creature.ManaCost.Select(m => m.ToString()).ToList(),
                        IsTapped = creature.IsTapped,
                        IsAttacking = creature.IsAttacking,
                        IsBlocked = creature.IsBlocked,
                        BlockedBy = creature.BlockedBy != null ? ConvertToCardDTO(creature.BlockedBy) as CreatureDTO : null
                    };

                case Land land:
                    return new LandDTO
                    {
                        Id = land.Id,
                        Name = land.Name,
                        LandType = land.Type.ToString(),
                        IsTapped = land.IsTapped
                    };

                default:
                    return new CardDTO
                    {
                        Id = card.Id,
                        Name = card.Name
                    };
            }
        }

        public CreatureDTO ConvertToCreatureDTO(Creature creature)
        {
            return new CreatureDTO
            {
                Id = creature.Id,
                Name = creature.Name,
                Power = creature.Power,
                Toughness = creature.Toughness,
                ManaCost = creature.ManaCost.Select(m => m.ToString()).ToList(),
                IsTapped = creature.IsTapped,
                IsAttacking = creature.IsAttacking,
                IsBlocked = creature.IsBlocked,
                BlockedBy = creature.BlockedBy != null ? ConvertToCardDTO(creature.BlockedBy) as CreatureDTO : null
            };
        }

        public LandDTO ConvertToLandDTO(Land land)
        {
            return new LandDTO
            {
                Id = land.Id,
                Name = land.Name,
                LandType = land.Type.ToString(),
                IsTapped = land.IsTapped
            };
        }

        public Creature ConvertToCreature(CreatureDTO creatureDTO)
        {
            return new Creature(creatureDTO.Name)
            {
                Id = creatureDTO.Id,
                IsTapped = creatureDTO.IsTapped,
                ManaCost = creatureDTO.ManaCost.Select(m => (Mana)Enum.Parse(typeof(Mana), m)),
                Power = creatureDTO.Power,
                Toughness = creatureDTO.Toughness,
                IsAttacking = creatureDTO.IsAttacking,
                IsBlocked = creatureDTO.IsBlocked,
            };
        }

        public Land ConvertToLand(LandDTO land)
        {
            var typeName = land.Type;
            Land returnLand;
            if (Enum.TryParse(typeName, true, out LandType type))
            {
                returnLand = new Land(type)
                {
                    Id = land.Id,
                    IsTapped = land.IsTapped
                };
            }
            else
            {
                returnLand = new Land(LandType.Forest)
                {
                    Id = land.Id,
                    IsTapped = land.IsTapped
                };
            }
            return returnLand;
        }

        public PlayerDTO ConvertToPlayerDTO(Player player)
        {
            return new PlayerDTO
            {
                Id = player.Id,
                Name = player.Name,
                Hand = player.Hand.Select(c => ConvertToCardDTO(c)).ToList(),
                Battlefield = player.Battlefield.Select(c => ConvertToCardDTO(c)).ToList(),
                Graveyard = player.Graveyard.Select(c => ConvertToCardDTO(c)).ToList(),
                Life = player.Life
            };
        }
    }
}

--------------------------------------------------
Filename: ICardConverter.cs
Path: D:/funandgiggels/Project-Aurora/Aurora\Shared\Utils\ICardConverter.cs
Content:
﻿using Aurora.Application.DTO;
using Aurora.Domain.Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Aurora.Shared.Utils
{
    public interface ICardConverter
    {
        CardDTO ConvertToCardDTO(Card card);
        PlayerDTO ConvertToPlayerDTO(Player player);
        Land ConvertToLand(LandDTO land);
        LandDTO ConvertToLandDTO(Land land);
        CreatureDTO ConvertToCreatureDTO(Creature creature);
        Creature ConvertToCreature(CreatureDTO creature);
    }
}

--------------------------------------------------
